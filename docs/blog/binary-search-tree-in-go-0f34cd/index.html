

<!DOCTYPE html>
<html lang="en">
<head>
  <!--
    Site Template By: Clavin June | https://github.com/anon-org/jekyll-blog
  -->
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatbile" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Clavin June" />
  <meta name="monetization" content="$ilp.uphold.com/RYNmdxrFrPJB" />
  <meta name="google-site-verification" content="SBb47aYmFt-bXzYsfAmQuGZSS3aD3EmDoq14GDSWKk8" />
  <meta name="keywords" content="go, data-structure, tree,  Development" />
  <meta name="description" content="This post contains my own experiences in reviewing my knowledge of BST data structure
" />
  <meta property="og:description" content="This post contains my own experiences in reviewing my knowledge of BST data structure
" />
  <meta property="og:title" content="Binary Search Tree In Go | Clavin June's detached brain" />
  <meta property="og:locale" content="en_US" />
  <meta property="og:url" content="https://clavinjune.dev/blog/binary-search-tree-in-go-0f34cd/" />
  <meta property="og:site_name" content="Clavin June's detached brain" />
  <meta property="og:image" content="https://images.unsplash.com/photo-1507100403890-47482dcd79e0?w=1920" />
  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2020-11-12T00:00:00+07:00" />
  
  <title> Binary Search Tree In Go | Clavin June's detached brain </title>
  <link rel="apple-touch-icon" sizes="180x180" href="https://clavinjune.dev/assets/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://clavinjune.dev/assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://clavinjune.dev/assets/favicon/favicon-16x16.png">
  
  <link rel="stylesheet" type="text/css" href="https://clavinjune.dev/assets/css/styles.css" />
  <link rel="stylesheet" type="text/css" href="https://clavinjune.dev/assets/css/syntax.css" />
</head>
<body>
<div class="progress-bar"></div>
<nav id="post">
  <a id="back" href="/">&larr;</a>
  <div>
    <a href="https://positif.dev" target="_blank">Podcast</a>
    <a href="/support">Support</a>
    <a href="https://gitconnected.com/clavinjune/resume" target="_blank">Author</a>
  </div>
</nav>
<main id="post">
  <div>
    <h1 class="title">Binary Search Tree In Go</h1>
    <div class="posts-time">
      <span>Nov 12, 2020</span>
      <span>&nbsp;&middot;&nbsp;</span>
      <span>~14min read</span>
    </div>
    <div class="posts-tags">
      <span class="posts-tags-category" id="f69c9a">
        Development
      </span>
        <span class="posts-tags-content">#data-structure</span>
      
        <span class="posts-tags-content">#go</span>
      
        <span class="posts-tags-content">#tree</span>
      
    </div>
  </div>
  <hr>
  <p><img src="https://images.unsplash.com/photo-1507100403890-47482dcd79e0?w=1920" alt="Photo by @danfreemanphoto on Unsplash" /></p>

<p>So long since I learned to create BST back then at university. I feel like wanna revisit the BST things, so I make this post. BST is not that scary. You only need to create a tree without duplicated value on each node, then the less valuable nodes go to the left, and then the rest of the nodes go to the right or vice-versa. In this post, I’ll make a BST in Go Language with less valuable nodes of integer go to the left. I assume you have a basic knowledge of Go Language and tree data structure.</p>

<h2 id="directory-structure">Directory Structure</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ tree
.
├── bst
│   ├── node.go
│   └── tree.go
├── go.mod
└── main.go
</code></pre></div></div>

<p>I used <code class="language-plaintext highlighter-rouge">tree</code> command to list down the directory structure (no pun intended).</p>

<h2 id="code">Code</h2>

<p>Let’s make a <code class="language-plaintext highlighter-rouge">node struct</code> first inside the <code class="language-plaintext highlighter-rouge">node.go</code> file.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">node</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">value</span>       <span class="kt">int</span>
  <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">*</span><span class="n">node</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">newNode</span><span class="p">(</span><span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">node</span><span class="p">{</span>
    <span class="n">value</span><span class="o">:</span> <span class="n">val</span><span class="p">,</span>
    <span class="n">left</span><span class="o">:</span>  <span class="no">nil</span><span class="p">,</span>
    <span class="n">right</span><span class="o">:</span> <span class="no">nil</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="n">Value</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="n">Left</span><span class="p">()</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">left</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="n">Right</span><span class="p">()</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">right</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I make it unexported so <code class="language-plaintext highlighter-rouge">user</code> can’t use <code class="language-plaintext highlighter-rouge">node struct</code> directly to avoid data mutability and give it some <code class="language-plaintext highlighter-rouge">getter functions</code>.</p>

<p>And then make <code class="language-plaintext highlighter-rouge">binarySearchTree struct</code> inside the <code class="language-plaintext highlighter-rouge">tree.go</code> file to wrap the usage of the <code class="language-plaintext highlighter-rouge">node</code>. It stores <code class="language-plaintext highlighter-rouge">pointer of node struct</code> as a <code class="language-plaintext highlighter-rouge">root</code> so we can keep track the root fo the tree.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">binarySearchTree</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">root</span> <span class="o">*</span><span class="n">node</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">New</span><span class="p">()</span> <span class="o">*</span><span class="n">binarySearchTree</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">binarySearchTree</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With current code, we can create the BST like this in <code class="language-plaintext highlighter-rouge">main function</code>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">tree</span> <span class="o">:=</span> <span class="n">bst</span><span class="o">.</span><span class="n">New</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now we want to give the tree some functionalities such as <code class="language-plaintext highlighter-rouge">insert</code>, <code class="language-plaintext highlighter-rouge">find</code>, <code class="language-plaintext highlighter-rouge">traverse</code>, and <code class="language-plaintext highlighter-rouge">remove</code>. Let’s go with <code class="language-plaintext highlighter-rouge">insert</code> first. The pseudo-code will be like this.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If there's no node, then create a new node.
If a node with same value is already exists inside the tree, returns error.
If the value is greater than current node's value, then insert to the right.
If the value is less than current node's value, then insert to the left.
</code></pre></div></div>

<p>We’ll make the function recursive and not directly change the tree value. So if there’s happened to be an error, the tree remains the same.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">insertNode</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// if there's no node, create one</span>
  <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">newNode</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">val</span> <span class="p">{</span>
    <span class="c">// if there's duplicated node returns error</span>
    <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">ErrDuplicatedNode</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
    <span class="c">// if value is greater than current node's value, insert to the right</span>
    <span class="n">right</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">insertNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>

    <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
    <span class="c">// if value is less than current node's value, insert to the left</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">insertNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>

    <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">node</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s expose the function to the user via the <code class="language-plaintext highlighter-rouge">binarySearchTree struct</code>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">binarySearchTree</span><span class="p">)</span> <span class="n">Insert</span><span class="p">(</span><span class="n">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="c">// always start insert from the root</span>
  <span class="n">root</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">insertNode</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">err</span>
  <span class="p">}</span>

  <span class="n">tree</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>
  <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To check whether the value we entered is in the correct position, then we create the traverse function first. There are 3 ways to traverse the tree, <code class="language-plaintext highlighter-rouge">pre-order</code>, <code class="language-plaintext highlighter-rouge">in-order</code>, and <code class="language-plaintext highlighter-rouge">post-order</code>. Here’s the difference:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># pre-order
1. print current value
2. go recursively to the left
3. go recursively to the right

# in-order
1. go recursively to the left
2. print current value
3. go recursively to the right

# post-order
1. go recursively to the left
2. go recursively to the right
3. print current value
</code></pre></div></div>

<p>To remember it easily, remember when you need to print the current value. if <code class="language-plaintext highlighter-rouge">pre</code> then print first, if<code class="language-plaintext highlighter-rouge"> post</code> then print at the end, otherwise print in the middle. we’re gonna make <code class="language-plaintext highlighter-rouge">in order traverse</code>, because it will go recursively to the left first and then print the value which means in our case it will print <code class="language-plaintext highlighter-rouge">from least valuable nodes to the greatest</code>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">traverse</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// exit condition</span>
  <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
  <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">binarySearchTree</span><span class="p">)</span> <span class="n">Traverse</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// traverse from the root</span>
  <span class="n">traverse</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s check our code first.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">tree</span> <span class="o">:=</span> <span class="n">bst</span><span class="o">.</span><span class="n">New</span><span class="p">()</span>

  <span class="n">tree</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="m">23</span><span class="p">)</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="m">15</span><span class="p">)</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="m">20</span><span class="p">)</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="m">25</span><span class="p">)</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="m">50</span><span class="p">)</span>

  <span class="n">tree</span><span class="o">.</span><span class="n">Traverse</span><span class="p">()</span> <span class="c">// 2 10 15 20 23 25 50</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now that you find your <code class="language-plaintext highlighter-rouge">traverse</code> results sorted, let’s move to the <code class="language-plaintext highlighter-rouge">find</code> function. To find a specific node you don’t have to go around the whole tree, you need to know that BST can route to a specific node by checking the node value. Just like the <code class="language-plaintext highlighter-rouge">insert</code> function, we only need to go to the left if the node value we are looking for is less than the current node and to the right, if the node value is greater.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">findNode</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">val</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="c">// if the node is found, return the node</span>
  <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">val</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">node</span>
  <span class="p">}</span>

  <span class="c">// if value is greater than current node's value, search recursively to the right</span>
  <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>  <span class="p">{</span>
    <span class="k">return</span> <span class="n">findNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// if value is less than current node's value, search recursively to the left</span>
  <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">findNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">binarySearchTree</span><span class="p">)</span> <span class="n">Find</span><span class="p">(</span><span class="n">val</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
  <span class="c">// as always, search from the root</span>
  <span class="k">return</span> <span class="n">findNode</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now we return the specified node if there is a node with given value otherwise, we return nil. Since we encapsulate the node attributes and leave the user only with the Getter function, there is no need to worry about data mutability.</p>

<p>Now let’s move to the <code class="language-plaintext highlighter-rouge">remove</code> function. Just like <code class="language-plaintext highlighter-rouge">insert</code> and <code class="language-plaintext highlighter-rouge">find</code> function, we need to locate the position of the node first and then do the deletion. There are 3 rules to remove a node from its tree.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If the node has no child, then Simply make it nil
If the node has 1 child, then move the child to the node position.
If the node has 2 children, then find the successor and move the successor to the node position.
</code></pre></div></div>

<p>To find the successor of the node there are 2 ways</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Find the least valueable node from the right child of the node
OR
Find the greatest valueable node from the left child of the node
</code></pre></div></div>

<p>I will use the first approach, <code class="language-plaintext highlighter-rouge">find the least valuable node of the right child node</code>. To find the least valuable node from the current node, you only need to go to the leftmost node. And to find the most valuable node of the current node, just go to the rightmost node.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">least</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">node</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">least</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">removeNode</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">ErrNodeNotFound</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
    <span class="n">right</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">removeNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>

    <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">removeNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>

    <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="c">// has 2 children</span>

      <span class="c">// find the successor</span>
      <span class="n">successor</span> <span class="o">:=</span> <span class="n">least</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
      <span class="n">value</span> <span class="o">:=</span> <span class="n">successor</span><span class="o">.</span><span class="n">value</span>

      <span class="c">// remove the successor</span>
      <span class="n">right</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">removeNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
      <span class="p">}</span>
      <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

      <span class="c">// copy the successor value to the current node</span>
      <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">||</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="c">// has 1 child</span>
      <span class="c">// move the child position to the current node</span>
      <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="c">// has no child</span>
      <span class="c">// simply remove the node</span>
      <span class="n">node</span> <span class="o">=</span> <span class="no">nil</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">node</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That’s all, folks. If I curate the code it will be like this.</p>

<h2 id="nodego">node.go</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">bst</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"errors"</span>
  <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">var</span> <span class="p">(</span>
  <span class="n">ErrDuplicatedNode</span> <span class="kt">error</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"bst: found duplicated value on tree"</span><span class="p">)</span>
  <span class="n">ErrNodeNotFound</span>   <span class="kt">error</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"bst: node not found"</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">node</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">value</span>       <span class="kt">int</span>
  <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">*</span><span class="n">node</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="n">Value</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="n">Left</span><span class="p">()</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">left</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="n">Right</span><span class="p">()</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">right</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">newNode</span><span class="p">(</span><span class="n">val</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">node</span><span class="p">{</span>
    <span class="n">value</span><span class="o">:</span> <span class="n">val</span><span class="p">,</span>
    <span class="n">left</span><span class="o">:</span>  <span class="no">nil</span><span class="p">,</span>
    <span class="n">right</span><span class="o">:</span> <span class="no">nil</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">insertNode</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// if there's no node, create one</span>
  <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">newNode</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">val</span> <span class="p">{</span>
    <span class="c">// if there's duplicated node returns error</span>
    <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">ErrDuplicatedNode</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
    <span class="c">// if value is greater than current node's value, insert to the right</span>
    <span class="n">right</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">insertNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>

    <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
    <span class="c">// if value is less than current node's value, insert to the left</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">insertNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>

    <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">node</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">removeNode</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">ErrNodeNotFound</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
    <span class="n">right</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">removeNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>

    <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">removeNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>

    <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="c">// has 2 children</span>

      <span class="c">// find the successor</span>
      <span class="n">successor</span> <span class="o">:=</span> <span class="n">least</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
      <span class="n">value</span> <span class="o">:=</span> <span class="n">successor</span><span class="o">.</span><span class="n">value</span>

      <span class="c">// remove the successor</span>
      <span class="n">right</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">removeNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
      <span class="p">}</span>
      <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

      <span class="c">// copy the successor value to the current node</span>
      <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">||</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="c">// has 1 child</span>
      <span class="c">// move the child position to the current node</span>
      <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="c">// has no child</span>
      <span class="c">// simply remove the node</span>
      <span class="n">node</span> <span class="o">=</span> <span class="no">nil</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">node</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">findNode</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">val</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="c">// if the node is found, return the node</span>
  <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">val</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">node</span>
  <span class="p">}</span>

  <span class="c">// if value is greater than current node's value, search recursively to the right</span>
  <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>  <span class="p">{</span>
    <span class="k">return</span> <span class="n">findNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// if value is less than current node's value, search recursively to the left</span>
  <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">findNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">least</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">node</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">least</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">traverse</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// exit condition</span>
  <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
  <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="treego">tree.go</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">bst</span>

<span class="k">type</span> <span class="n">binarySearchTree</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">root</span> <span class="o">*</span><span class="n">node</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">New</span><span class="p">()</span> <span class="o">*</span><span class="n">binarySearchTree</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">binarySearchTree</span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">binarySearchTree</span><span class="p">)</span> <span class="n">Insert</span><span class="p">(</span><span class="n">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="c">// always start insert from the root</span>
  <span class="n">root</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">insertNode</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">err</span>
  <span class="p">}</span>

  <span class="n">tree</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>
  <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">binarySearchTree</span><span class="p">)</span> <span class="n">Remove</span><span class="p">(</span><span class="n">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="n">root</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">removeNode</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">err</span>
  <span class="p">}</span>

  <span class="n">tree</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>
  <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">binarySearchTree</span><span class="p">)</span> <span class="n">Find</span><span class="p">(</span><span class="n">val</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
  <span class="c">// as always, search from the root</span>
  <span class="k">return</span> <span class="n">findNode</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">binarySearchTree</span><span class="p">)</span> <span class="n">Traverse</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// traverse from the root</span>
  <span class="n">traverse</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="maingo">main.go</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"learn/bst"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">tree</span> <span class="o">:=</span> <span class="n">bst</span><span class="o">.</span><span class="n">New</span><span class="p">()</span>

  <span class="n">tree</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="m">23</span><span class="p">)</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="m">15</span><span class="p">)</span>

  <span class="n">tree</span><span class="o">.</span><span class="n">Remove</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>

  <span class="n">tree</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="m">20</span><span class="p">)</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="m">25</span><span class="p">)</span>

  <span class="n">tree</span><span class="o">.</span><span class="n">Remove</span><span class="p">(</span><span class="m">25</span><span class="p">)</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">Remove</span><span class="p">(</span><span class="m">23</span><span class="p">)</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="m">50</span><span class="p">)</span>

  <span class="n">tree</span><span class="o">.</span><span class="n">Traverse</span><span class="p">()</span> <span class="c">// 2 15 20 50</span>
<span class="p">}</span>
</code></pre></div></div>

  <div>Thank you for reading!</div>
  <footer>
    <hr>
    <span>Copyright &copy; 2021 &middot; Clavin June</span>
    </div>
  </footer>
</main><script defer type="text/javascript" src="https://clavinjune.dev/assets/js/index.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script defer src="https://www.googletagmanager.com/gtag/js?id=G-MTSJ0LHJ06"></script>
<script defer type="text/javascript">
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MTSJ0LHJ06');
</script>
</body>
</html>