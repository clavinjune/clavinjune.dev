

<!DOCTYPE html>
<html lang="en">
<head>
  <!--
    Site Template By: Clavin June | https://github.com/anon-org/jekyll-blog
  -->
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatbile" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Clavin June" />
  <meta name="monetization" content="$ilp.uphold.com/RYNmdxrFrPJB" />
  <meta name="google-site-verification" content="n8iUJq2zr7wQ8eTS_ozpypgZQhfezUeUOXhOr3-INrE" />
  <meta name="keywords" content="go, data-structure, cache,  Development" />
  <meta name="description" content="This post contains notes on how to implementing least recently used (LRU) cache in Golang that has O(1) Time Complexity.
" />
  <meta property="og:description" content="This post contains notes on how to implementing least recently used (LRU) cache in Golang that has O(1) Time Complexity.
" />
  <meta property="og:title" content="LRU Cache in Go | Clavin June's detached brain" />
  <meta property="og:locale" content="en_US" />
  <meta property="og:url" content="https://clavinjune.dev/blog/lru-cache-in-go-e7351e/" />
  <meta property="og:site_name" content="Clavin June's detached brain" />
  <meta property="og:image" content="https://images.unsplash.com/photo-1580188911874-f95af62924ee?w=1920" />
  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2021-02-06T00:00:00+07:00" />
  
  <title> LRU Cache in Go | Clavin June's detached brain </title>
  <link rel="apple-touch-icon" sizes="180x180" href="https://clavinjune.dev/assets/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://clavinjune.dev/assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://clavinjune.dev/assets/favicon/favicon-16x16.png">
  
  <link rel="stylesheet" type="text/css" href="https://clavinjune.dev/assets/css/styles.css" />
  <link rel="stylesheet" type="text/css" href="https://clavinjune.dev/assets/css/syntax.css" />
</head>
<body>
<div class="progress-bar"></div>
<nav id="post">
  <a id="back" href="/">&larr;</a>
  <div>
    <a href="https://positif.dev" target="_blank">Podcast</a>
    <a href="/support">Support</a>
    <a href="https://gitconnected.com/clavinjune/resume" target="_blank">Author</a>
  </div>
</nav>
<main id="post">
  <div>
    <h1 class="title">LRU Cache in Go</h1>
    <div class="posts-time">
      <span>Feb 06, 2021</span>
      <span>&nbsp;&middot;&nbsp;</span>
      <span>~8min read</span>
    </div>
    <div class="posts-tags">
      <span class="posts-tags-category" id="f69c9a">
        Development
      </span>
        <span class="posts-tags-content">#cache</span>
      
        <span class="posts-tags-content">#data-structure</span>
      
        <span class="posts-tags-content">#go</span>
      
    </div>
  </div>
  <hr>
  <p><img src="https://images.unsplash.com/photo-1580188911874-f95af62924ee?w=1920" alt="Photo by @mrthetrain on Unsplash" /></p>

<p>Two days ago, I failed to implement the optimized LRU cache in coding interview due to panic and stopped by the interviewer. Yes, I suck at coding interviews. I have implemented LRU cache before, so I know how it works and of course know how to implement it. But if you never heard of it, I think <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)">this explanation</a> is enough.</p>

<h2 id="brief-definition">Brief definition</h2>

<p>LRU Cache is a combination of hash map and queue. Hash map will store the elements by keys and values while the queue keeps track the least recently used keys. We will implement the queue using doubly linked list.</p>

<h2 id="rules">Rules</h2>

<ol>
  <li>Track each key usage</li>
  <li>Set max capacity that LRU cache will handle</li>
  <li>If the size is over the defined capacity, remove the least recently used data, and store the new data</li>
  <li>Accessed (get/set) the data means we use the data so mark it as the most recently used data</li>
</ol>

<h2 id="node-structure">Node Structure</h2>

<p>Node structure will store the key, value, and its previous &amp; next nodes (doubly linked list).</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Node</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Key</span>   <span class="kt">int</span>
  <span class="n">Value</span> <span class="kt">int</span>
  <span class="n">Prev</span>  <span class="o">*</span><span class="n">Node</span>
  <span class="n">Next</span>  <span class="o">*</span><span class="n">Node</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">Node</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">Node</span><span class="p">{</span>
    <span class="n">Key</span><span class="o">:</span>   <span class="n">key</span><span class="p">,</span>
    <span class="n">Value</span><span class="o">:</span> <span class="n">value</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="lru-structure">LRU Structure</h2>

<p>LRU will store the capacity, size (optional), the stored data, and it will track the most and the least recently used using tail and head pointer. Size is optional since you can use <code class="language-plaintext highlighter-rouge">len(v Type)</code> method.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">LRU</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">capacity</span> <span class="kt">int</span>
  <span class="n">size</span>     <span class="kt">int</span>
  <span class="n">data</span>     <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="n">Node</span>
  <span class="n">tail</span>     <span class="o">*</span><span class="n">Node</span>
  <span class="n">head</span>     <span class="o">*</span><span class="n">Node</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewLRU</span><span class="p">(</span><span class="n">capacity</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">LRU</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">LRU</span><span class="p">{</span>
    <span class="n">capacity</span><span class="o">:</span> <span class="n">capacity</span><span class="p">,</span>
    <span class="n">size</span><span class="o">:</span>     <span class="m">0</span><span class="p">,</span>
    <span class="n">data</span><span class="o">:</span>     <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="n">Node</span><span class="p">),</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="queue-operation">Queue Operation</h2>

<h3 id="push-tail">Push Tail</h3>

<p>Push tail will append the given node to the queue.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">LRU</span><span class="p">)</span> <span class="n">pushTail</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="n">l</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">n</span><span class="o">.</span><span class="n">Prev</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span>
  <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">l</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop-head">Pop Head</h3>

<p>Pop head will remove the head (least recently used) node.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">LRU</span><span class="p">)</span> <span class="n">popHead</span><span class="p">()</span> <span class="o">*</span><span class="n">Node</span> <span class="p">{</span>
  <span class="n">ret</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span>

  <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="p">{</span>
    <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="no">nil</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">Next</span>
    <span class="n">l</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">Prev</span> <span class="o">=</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">ret</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop-tail">Pop Tail</h3>

<p>Pop tail will remove the tail (most recently used) node. We will not use this method directly, but it will be used later whenever user reset the tail value.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">LRU</span><span class="p">)</span> <span class="n">popTail</span><span class="p">()</span> <span class="o">*</span><span class="n">Node</span> <span class="p">{</span>
  <span class="n">ret</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span>

  <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="p">{</span>
    <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="no">nil</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">Prev</span>
    <span class="n">l</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">ret</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop">Pop</h3>

<p>This Pop method will receive node that we want to pop.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">LRU</span><span class="p">)</span> <span class="n">pop</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="o">*</span><span class="n">Node</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="n">n</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="n">popHead</span><span class="p">()</span>
  <span class="k">case</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="n">popTail</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="n">n</span><span class="o">.</span><span class="n">Next</span><span class="o">.</span><span class="n">Prev</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">Prev</span>
  <span class="n">n</span><span class="o">.</span><span class="n">Prev</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">Next</span>
  <span class="k">return</span> <span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now all the queue operations has defined, let’s implement the main operation of the LRU.</p>

<h2 id="set">Set</h2>

<p>Set method will store the given value identified by the given key. Remember the 3rd and 4th rules.</p>

<blockquote>
  <ul>
    <li>If the size is over the defined capacity, remove the least recently used data, and store the new data</li>
    <li>Accessed (get/set) the data means we use the data so mark it as the most recently used data</li>
  </ul>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">LRU</span><span class="p">)</span> <span class="n">Set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// check if the key exists</span>
  <span class="c">// if it exists, we need to remove it</span>
  <span class="c">// then we append it to the queue</span>
  <span class="c">// 4th rule (mark it as the most recently used)</span>
  <span class="k">if</span> <span class="n">val</span><span class="p">,</span> <span class="n">isOk</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">];</span> <span class="n">isOk</span> <span class="p">{</span>
    <span class="c">// this is the reason why we need to use popTail</span>
    <span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">size</span><span class="o">--</span>
  <span class="p">}</span>

  <span class="c">// 3rd rule</span>
  <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="o">.</span><span class="n">capacity</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">popHead</span><span class="p">()</span>
    <span class="nb">delete</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">Key</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">size</span><span class="o">--</span>
  <span class="p">}</span>

  <span class="c">// push new data</span>
  <span class="n">n</span> <span class="o">:=</span> <span class="n">NewNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
  <span class="n">l</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">l</span><span class="o">.</span><span class="n">pushTail</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">l</span><span class="o">.</span><span class="n">size</span><span class="o">++</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="get">Get</h2>

<p>Get method will return the stored value depends on the given key. Remember the 4th rule.</p>

<blockquote>
  <ul>
    <li>Accessed (get/set) the data means we use the data so mark it as the most recently used data</li>
  </ul>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">LRU</span><span class="p">)</span> <span class="n">Get</span><span class="p">(</span><span class="n">key</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">val</span><span class="p">,</span> <span class="n">isOk</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

  <span class="k">if</span> <span class="o">!</span><span class="n">isOk</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="m">1</span>
  <span class="p">}</span>

  <span class="c">// remove it</span>
  <span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="c">// then mark it as the most recently used</span>
  <span class="n">l</span><span class="o">.</span><span class="n">pushTail</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">Value</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Lastly, to ensure our queue rotation is correct, let’s implement the showQueue method.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">LRU</span><span class="p">)</span> <span class="n">ShowQueue</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Least "</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="p">;</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">Next</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v -&gt; "</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">Key</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="s">"Most"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s test it</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lru</span> <span class="o">:=</span> <span class="n">NewLRU</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
  <span class="n">lru</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
  <span class="n">lru</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
  <span class="n">lru</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>

  <span class="c">// Least 1 -&gt; 2 -&gt; 3 Most</span>
  <span class="n">lru</span><span class="o">.</span><span class="n">ShowQueue</span><span class="p">()</span>

  <span class="c">// 2</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">lru</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="m">2</span><span class="p">))</span>
  <span class="c">// Least 1 -&gt; 3 -&gt; 2 Most</span>
  <span class="n">lru</span><span class="o">.</span><span class="n">ShowQueue</span><span class="p">()</span>

  <span class="n">lru</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span>
  <span class="c">// Least 3 -&gt; 2 -&gt; 1 Most</span>
  <span class="n">lru</span><span class="o">.</span><span class="n">ShowQueue</span><span class="p">()</span>

  <span class="n">lru</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>
  <span class="c">// Least 2 -&gt; 1 -&gt; 4 Most</span>
  <span class="n">lru</span><span class="o">.</span><span class="n">ShowQueue</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The whole code should be like this:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">Node</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Key</span>   <span class="kt">int</span>
  <span class="n">Value</span> <span class="kt">int</span>
  <span class="n">Prev</span>  <span class="o">*</span><span class="n">Node</span>
  <span class="n">Next</span>  <span class="o">*</span><span class="n">Node</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">Node</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">Node</span><span class="p">{</span>
    <span class="n">Key</span><span class="o">:</span>   <span class="n">key</span><span class="p">,</span>
    <span class="n">Value</span><span class="o">:</span> <span class="n">value</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">LRU</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">capacity</span> <span class="kt">int</span>
  <span class="n">size</span>     <span class="kt">int</span>
  <span class="n">data</span>     <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="n">Node</span>
  <span class="n">tail</span>     <span class="o">*</span><span class="n">Node</span>
  <span class="n">head</span>     <span class="o">*</span><span class="n">Node</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewLRU</span><span class="p">(</span><span class="n">capacity</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">LRU</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">LRU</span><span class="p">{</span>
    <span class="n">capacity</span><span class="o">:</span> <span class="n">capacity</span><span class="p">,</span>
    <span class="n">size</span><span class="o">:</span>     <span class="m">0</span><span class="p">,</span>
    <span class="n">data</span><span class="o">:</span>     <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="n">Node</span><span class="p">),</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">LRU</span><span class="p">)</span> <span class="n">pushTail</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="n">l</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">n</span><span class="o">.</span><span class="n">Prev</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span>
  <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">l</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">LRU</span><span class="p">)</span> <span class="n">popHead</span><span class="p">()</span> <span class="o">*</span><span class="n">Node</span> <span class="p">{</span>
  <span class="n">ret</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span>

  <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="p">{</span>
    <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="no">nil</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">Next</span>
    <span class="n">l</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">Prev</span> <span class="o">=</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">ret</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">LRU</span><span class="p">)</span> <span class="n">popTail</span><span class="p">()</span> <span class="o">*</span><span class="n">Node</span> <span class="p">{</span>
  <span class="n">ret</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span>

  <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="p">{</span>
    <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="no">nil</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">Prev</span>
    <span class="n">l</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">ret</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">LRU</span><span class="p">)</span> <span class="n">pop</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="o">*</span><span class="n">Node</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="n">n</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="n">popHead</span><span class="p">()</span>
  <span class="k">case</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="n">popTail</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="n">n</span><span class="o">.</span><span class="n">Next</span><span class="o">.</span><span class="n">Prev</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">Prev</span>
  <span class="n">n</span><span class="o">.</span><span class="n">Prev</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">Next</span>
  <span class="k">return</span> <span class="n">n</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">LRU</span><span class="p">)</span> <span class="n">Set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// check if the key exists</span>
  <span class="c">// if it exists, we need to remove it</span>
  <span class="c">// then we append it to the queue</span>
  <span class="c">// 4th rule (mark it as the most recently used)</span>
  <span class="k">if</span> <span class="n">val</span><span class="p">,</span> <span class="n">isOk</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">];</span> <span class="n">isOk</span> <span class="p">{</span>
    <span class="c">// this is the reason why we need to use popTail</span>
    <span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">size</span><span class="o">--</span>
  <span class="p">}</span>

  <span class="c">// 3rd rule</span>
  <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="o">.</span><span class="n">capacity</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">popHead</span><span class="p">()</span>
    <span class="nb">delete</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">Key</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">size</span><span class="o">--</span>
  <span class="p">}</span>

  <span class="c">// push new data</span>
  <span class="n">n</span> <span class="o">:=</span> <span class="n">NewNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
  <span class="n">l</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">l</span><span class="o">.</span><span class="n">pushTail</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">l</span><span class="o">.</span><span class="n">size</span><span class="o">++</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">LRU</span><span class="p">)</span> <span class="n">Get</span><span class="p">(</span><span class="n">key</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">val</span><span class="p">,</span> <span class="n">isOk</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

  <span class="k">if</span> <span class="o">!</span><span class="n">isOk</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="m">1</span>
  <span class="p">}</span>

  <span class="c">// remove it</span>
  <span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="c">// then mark it as the most recently used</span>
  <span class="n">l</span><span class="o">.</span><span class="n">pushTail</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">Value</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">LRU</span><span class="p">)</span> <span class="n">ShowQueue</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Least "</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span><span class="p">;</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">Next</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v -&gt; "</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">Key</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="s">"Most"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lru</span> <span class="o">:=</span> <span class="n">NewLRU</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
  <span class="n">lru</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
  <span class="n">lru</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
  <span class="n">lru</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>

  <span class="c">// Least 1 -&gt; 2 -&gt; 3 Most</span>
  <span class="n">lru</span><span class="o">.</span><span class="n">ShowQueue</span><span class="p">()</span>

  <span class="c">// 2</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">lru</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="m">2</span><span class="p">))</span>
  <span class="c">// Least 1 -&gt; 3 -&gt; 2 Most</span>
  <span class="n">lru</span><span class="o">.</span><span class="n">ShowQueue</span><span class="p">()</span>

  <span class="n">lru</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span>
  <span class="c">// Least 3 -&gt; 2 -&gt; 1 Most</span>
  <span class="n">lru</span><span class="o">.</span><span class="n">ShowQueue</span><span class="p">()</span>

  <span class="n">lru</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>
  <span class="c">// Least 2 -&gt; 1 -&gt; 4 Most</span>
  <span class="n">lru</span><span class="o">.</span><span class="n">ShowQueue</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

  <div>Thank you for reading!</div>
  <footer>
    <hr>
    <span>Copyright &copy; 2021 &middot; Clavin June</span>
    </div>
  </footer>
</main><script defer type="text/javascript" src="https://clavinjune.dev/assets/js/index.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script defer src="https://www.googletagmanager.com/gtag/js?id=G-MTSJ0LHJ06"></script>
<script defer type="text/javascript">
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MTSJ0LHJ06');
</script>
</body>
</html>